from datetime import datetime
import os
import glob 
import base64
import hashlib
import hmac
import requests
import time
import uuid
from urllib import parse
import pandas as pd
import http.client
import json
from pydub import AudioSegment
from pydub.silence import split_on_silence
import threading
import you_get
import numpy as np
import subprocess
import zipfile


'''
全局变量声明
'''
rootpath='C:\\Users\\Administrator\\Desktop\\test2\\'
chunkspath=rootpath+'chunks\\'
wavpath=rootpath+'转wav\\'
logpath=rootpath+'日志\\'
dataurl=pd.read_csv('C:\\Users\\Administrator\\Desktop\\下载链接.txt',header=None,sep='\t')
data2=pd.DataFrame(data=None,columns=['编号','语音内容'])

#阿里云参数
access_key_id = 'LTAI5tDCdQARDVh2XYMjJGLa'
access_key_secret = 'znwuFhoqj6i9ojEwZWuPE4Hmp8anzs'
appKey = 'gF3HRZAKLeo6uD84'

class AccessToken:
    @staticmethod
    def _encode_text(text):
        encoded_text = parse.quote_plus(text)
        return encoded_text.replace('+', '%20').replace('*', '%2A').replace('%7E', '~')
    @staticmethod
    def _encode_dict(dic):
        keys = dic.keys()
        dic_sorted = [(key, dic[key]) for key in sorted(keys)]
        encoded_text = parse.urlencode(dic_sorted)
        return encoded_text.replace('+', '%20').replace('*', '%2A').replace('%7E', '~')
    @staticmethod
    def create_token(access_key_id, access_key_secret):
        parameters = {'AccessKeyId': access_key_id,
                      'Action': 'CreateToken',
                      'Format': 'JSON',
                      'RegionId': 'cn-shanghai',
                      'SignatureMethod': 'HMAC-SHA1',
                      'SignatureNonce': str(uuid.uuid1()),
                      'SignatureVersion': '1.0',
                      'Timestamp': time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                      'Version': '2019-02-28'}
        # 构造规范化的请求字符串
        query_string = AccessToken._encode_dict(parameters)
        #print('规范化的请求字符串: %s' % query_string)
        # 构造待签名字符串
        string_to_sign = 'GET' + '&' + AccessToken._encode_text('/') + '&' + AccessToken._encode_text(query_string)
        #print('待签名的字符串: %s' % string_to_sign)
        # 计算签名
        secreted_string = hmac.new(bytes(access_key_secret + '&', encoding='utf-8'),
                                   bytes(string_to_sign, encoding='utf-8'),
                                   hashlib.sha1).digest()
        signature = base64.b64encode(secreted_string)
        #print('签名: %s' % signature)
        # 进行URL编码
        signature = AccessToken._encode_text(signature)
        #print('URL编码后的签名: %s' % signature)
        # 调用服务
        full_url = 'http://nls-meta.cn-shanghai.aliyuncs.com/?Signature=%s&%s' % (signature, query_string)
        # print('url: %s' % full_url)
        # 提交HTTP GET请求
        response = requests.get(full_url)
        if response.ok:
            root_obj = response.json()
            key = 'Token'
            if key in root_obj:
                token = root_obj[key]['Id']
                expire_time = root_obj[key]['ExpireTime']
                return token, expire_time
        #print(response.text)
        return None, None

token, expire_time = AccessToken.create_token(access_key_id, access_key_secret)
url = 'https://nls-gateway-cn-shanghai.aliyuncs.com/stream/v1/asr'
format = 'pcm'
sampleRate = 16000
enablePunctuationPrediction  = True
enableInverseTextNormalization = True
enableVoiceDetection  = False

request = url + '?appkey=' + appKey
request = request + '&format=' + format
request = request + '&sample_rate=' + str(sampleRate)

if enablePunctuationPrediction :
    request = request + '&enable_punctuation_prediction=' + 'true'

if enableInverseTextNormalization :
    request = request + '&enable_inverse_text_normalization=' + 'true'

if enableVoiceDetection :
    request = request + '&enable_voice_detection=' + 'true'




timetotal1=datetime.now()

def remove_file(*path,type=all):
    '''函数作用就是删除不同指定路径下指定格式的文件
        type 必须是.mp3区分文件夹跟文件
        path必须是末尾返斜杠
    '''
    for i in range(0,len( path),1):
        
        if type=='all':
            newpath=path[i]+'*'
            for file in glob.glob(newpath):
                os.remove(file)
        else :
            newpath=path[i]
            for f in os.listdir(newpath):
                if  f.endswith(type):
                    os.remove(newpath+f)

def downfenbianlv(downloadfile,url):
'''
  下载最低画质视频
'''
    try:
        os.system("you-get -o "+downloadfile+"  --format=dash-flv360 "+url)
    except:
        os.system("you-get -o "+downloadfile+" --format=dash-flv720 "+url)
    except:
        os.system("you-get -o "+downloadfile+"  "+url)


def download(dataurl):
'''
多线程下载函数，不放在一块是为了后面代码可移植性，不重复在一块
dataurl是series
'''

    thread_list = []
    thread_num = 8
    for i in range(1,len(dataurl)+1):
        #为每个新URL创建下载线程
        url = dataurl[i-1]
    
        t = threading.Thread(target=downfenbianlv, args=(downloadfile,url))
        thread_list.append(t)
        t.start()

        #当线程池满时，等待线程结束
    while len(thread_list)>thread_num:  
            #移除已结束线程
        thread_list = [x for x in thread_list if x.is_alive()]
        time.sleep(3)




def trans_format(downloadfile,to_save_trans,oldformat,newformat):
'''
  格式转换  mp4转换成mp3 mp3转换成pcm
'''
          
    #批量转换格式转换为mp3并删除mp4
    if newformat=='.mp3':
        for i in os.listdir(downloadfile):
            if  os.path.splitext(i)[-1]==oldformat:
                trans_name=downloadfile+i
                save_name=downladfile+os.path.splitext(i)[0]+newformat
                code='ffmpeg -y -i ' +trans_name+' -f mp3 '+save_name
                subprocess.check_output(code,shell=True)
    elif newformat=='.pcm':
        for i in os.listdir(downloadfile):
            trans_name=downloadfile+i
            save_name=to_save_trans+os.path.splitext(i)[0]+'.pcm'
            code='ffmpeg -y -i ' +trans_name+' -acodec pcm_s16le -f s16le -ac 1 -ar 16000 '+save_name
            subprocess.check_output(code,shell=True)

    else:
        print('要转换的格式错误')

def split_trans(audiopath):
    '''
定义分解转换，方便后面多线程调用，阿里云单独两个线程
'''
    audiopath=rootpath
    sound = AudioSegment.from_file(audiopath, format='mp3')
    chunks = split_on_silence(sound,min_silence_len=520,silence_thresh=-30,keep_silence=800)#min_silence_len: 拆分语句时，静默满0.3秒则拆分。silence_thresh：小于-70dBFS以下的为静默。
    if not os.path.exists(chunks_path):os.mkdir(chunks_path)
    for i in range(len(chunks)):
        new = chunks[i]
        save_name = chunks_path+audioname+'%04d.%s'%(i,'mp3')
        new.export(save_name, format='mp3')
        mp3name=save_name.split("\\")[-1]
        pcm_name=wavpath+os.path.splitext(mp3name)[0]+'.pcm'
        code='ffmpeg -y -i ' +save_name+' -acodec pcm_s16le -f s16le -ac 1 -ar 16000 '+pcm_name
        subprocess.check_output(code,shell=True)


  #批量上传到阿里云



def rename_test(audiofile):
'''
将test2下mp3进行重命名，命名成数字，避免中文出现问题

'''

    onum=0
    upnum=100
    for i in os.listdir(audiofile):
    #将mp3进行重命名，命名成数字，避免中文出现问题
       if  os.path.splitext(i)[-1]=='.mp3':
        
            onum+=1
            onewname=audiofile+str(upnum)+'.mp3'
        
            os.rename(audiofile+i,onewname)
            upnum+=1
    return onum

def process(request, token, audioFile) :
'''
阿里云第一段代码
'''

    # 读取音频文件
    with open(audioFile, mode = 'rb') as f:
        audioContent = f.read()

    host = 'nls-gateway-cn-shanghai.aliyuncs.com'

    # 设置HTTPS请求头部
    httpHeaders = {
        'X-NLS-Token': token,
        'Content-type': 'application/octet-stream',
        'Content-Length': len(audioContent)
        }


    # Python 2.x使用httplib
    # conn = httplib.HTTPConnection(host)

    # Python 3.x使用http.client
    conn = http.client.HTTPConnection(host)
    conn.request(method='POST', url=request, body=audioContent, headers=httpHeaders)
    response = conn.getresponse()
    # print('Response status and response reason:')
    # print(response.status ,response.reason)
    body = response.read()
    try:
        # print('Recognize response is:')
        body = json.loads(body)
        # print(body)

        status = body['status']
        if status == 20000000 :
            result = body['result']
#           # print('Recognize result: ' + result)
            return result
        else :
            print('Recognizer failed!')

    except ValueError:
        print('The response is not json format string')

    conn.close()



def part_aliyun(start,end):
'''
传递一部分到阿里云 start从1开始
'''
    
    for i in range(start-1,end,1):
        aliyun_wav=wavpath+all_name[i]

        result= process(request, token, aliyun_wav)

        dic ={'编号':num,'语音内容':result}
        data1=pd.DataFrame(dic,index=[0])
        data2=data2.append(data1,ignore_index=True)

    
        

def rename_mp3():
    '''
重新命名
'''
    rename_file=chunkspath
    data3=data2.groupby(data2['编号'])['语音内容'].apply(lambda x:x.str.cat(sep=''))
    no_logo=['*',':','\'','<','>','|','\\','/','?']

    for i in no_logo:
        data3 =data3.apply(lambda x:x.replace( i,''))
        data3=data3.apply(lambda x:x[:80] if len(x)>81 else x)
    data3=data3.dropna(axis=0,how='any')
    data3.drop(data3[data3.values==''].index,inplace=True)
    data3.drop_duplicates(keep='first',inplace=True)
    for i in os.listdir(rename_file):
        for j in data3.index:
            jstr=str(j)
            jj=jstr.zfill(6)

            if os.path.splitext(i)[0]==jj:
                old_file=rename_file+i
               #好兄弟加后缀的话放在这里，下面带#的代码就是例子，比这来
      #        new_file=rename_file+data3[j]+'（素材分享群：123593137，获取更多素材）.mp3'
                new_file=rename_file+data3[j]+'.mp3'
                os.rename(old_file,new_file)

    data2['编号']=data2['编号'].astype(str)

    for i in os.listdir(rename_file):
        for j in data2['编号']:
            jstr=str(j)
            jj=jstr.zfill(6)
            if os.path.exists(rename_file+jj+'.mp3'):
                os.remove(rename_file+jj+'.mp3')







if __name__ == "__main__":
    #初始化参数各个路径
    rootpath='C:\\Users\\Administrator\\Desktop\\test2\\'
    chunkspath=rootpath+'chunks\\'
    wavpath=rootpath+'转wav\\'
    logpath=rootpath+'日志\\'
    dataurl=pd.read_csv('C:\\Users\\Administrator\\Desktop\\下载链接.txt',header=None,sep='\t')
    #删除chunks wav下所有文件，test2下mp3以及rar文件

    remove_file(rootpath,type='.zip')
    remove_file(chunkspath,wavpath,type='all')

    #下载完成之后清空桌面下载链接,重新做已经存在，跑新的就不为空
    if dataurl.empty is False:
        print('正在下载链接中语音')
        remove_file(rootpath,type='.mp3')
        download(dataurl)
    else:
        print('跳过下载，直接使用test2里面mp3')

    #清空桌面下载链接中的链接
    file = open(dataurl, 'w').close()

    trans_format(rootpath,rootpath,'.mp4','.mp3')

    remove_file(rootpath,type='.xml')
    remove_file(rootpath,type='.mp4')
   
    onum=rename_test(rootpath)
    
    thread_list = []
    thread_num = 8
    for i in range(100,100+onum,1):
        audioname=str(i)
        audiopath=audiofile+audioname+'.mp3'
        t = threading.Thread(target=split_trans, args=(audiopath))
        thread_list.append(t)
        t.start()

        while len(thread_list)>thread_num:  
            #移除已结束线程
            thread_list = [x for x in thread_list if x.is_alive()]
            time.sleep(3)

    #获取转wav下所有文件构造列表，进行多线程
    all_name=[]
    for i in os.listdir(wavpath):
        all_name.append(i)
    trans_num=len(all_name)
    #两个线程上传阿里云
    threads=[ threading.Thread(target=part_aliyun, args=(1,int(trans_num/2)),
              threading.Thread(target=part_aliyun, args=(int(trans_num/2),trans_num)]
    for t in threads:
        t.start()

    now_time=datetime.now().strftime('%Y%m%d%H%M%S')
    log_file=rootpath+"日志\\"+now_time+'.txt'
    data2.to_csv(log_file,index=False,sep=' ')




   
   

 for i in os.listdir(wavpath):
        num=os.path.splitext(i)[0]
        aliyun_wav=wavpath+'\\'+i
        result= process(request, token, aliyun_wav)
    # print(num,result)
        dic ={'编号':num,'语音内容':result}
        data1=pd.DataFrame(dic,index=[0])
        data2=data2.append(data1,ignore_index=True)

    



  #批量删除弹幕文件

    for f in os.listdir(downloadfile):
        if f.endswith(u'.xml'):
            os.remove(downloadfile+f)



                 
# print('———chunks目录下文件删除完成———')
for file in glob.glob("C:\\Users\\Administrator\\Desktop\\test2\\转wav\\*"):
    os.remove(file)
# print('———转wav目录下文件删除完成———')
test2path='C:\\Users\\Administrator\\Desktop\\test2\\'
for i in os.listdir(test2path):
    if  os.path.splitext(i)[-1]=='.mp3' or os.path.splitext(i)[-1]=='.zip':
        os.remove(test2path+i)
# print('———test2目录下mp3zip删除完成———')
print('***运行下载代码***')
time_2=datetime.now()






#第二部分代码
#功能：批量下载视频并自动提取mp3到test2文件夹下
import you_get
import threading
import os
import time
import pandas as pd
import subprocess

time_3=datetime.now()

def download1080(count,url,downloadfile):
    #print("thread "+ str(count) +" is running")
    os.system("you-get -o "+downloadfile+" --format=dash-flv "+url)

def download720(count,url,downloadfile):
    #print("thread "+ str(count) +" is running")
    os.system("you-get -o "+downloadfile+"  --format=dash-flv720 "+url)


def download360(count,url,downloadfile):
    #print("thread "+ str(count) +" is running")
    os.system("you-get -o "+downloadfile+" --format=dash-flv360 "+url)

def downloaddefault(count,url,downloadfile):
    #print("thread "+ str(count) +" is running")
    os.system("you-get -o "+downloadfile+"  "+url)

def showinfo(count,url):
    #print("thread "+ str(count) +" is running")
    os.system("you-get -i "+url)

def test(arg):
    #print("thread "+ str(arg) +" s running")
    os.system("ping www.baidu.com")
    #print("thread "+ str(arg) +" finish")

def extract_mp3(downloadfile):
    #批量删除弹幕文件

    for f in os.listdir(downloadfile):
        if f.endswith(u'.xml'):
            os.remove(downloadfile+f)
    #批量转换格式转换为mp3并删除mp4
    for i in os.listdir(downloadfile):
        if  os.path.splitext(i)[-1]=='.mp4':
            trans_name=downloadfile+i
            save_name=downladfile+os.path.splitext(i)[0]+'.mp3'
            code='ffmpeg -y -i ' +trans_name+' -f mp3 '+save_name
            subprocess.check_output(code,shell=True)
            os.remove(trans_name)
    # print('视频全部提取mp3')

   



downloadfile='C:\\Users\\Administrator\\Desktop\\test2\\'
dataurl=pd.read_csv('C:\\Users\\Administrator\\Desktop\\下载链接.txt',header=None,sep='\t'
thread_list = []
    
thread_num = 8

for i in range(1,len(dataurl)+1):
        #为每个新URL创建下载线程
    url = dataurl[i-1]
    try:
        t = threading.Thread(target=download360, args=(i,url,downloadfile))
            #先下载360分辨率
        thread_list.append(t)
        t.start()
    except:
        t = threading.Thread(target=download720, args=(i,url,downloadfile))
            #没有360分辨率下载720
        thread_list.append(t)
        t.start()
    except:
        t = threading.Thread(target=downloaddefault, args=(i,url,downloadfile))
            # 没有720分辨率下载最高画质
        thread_list.append(t)
        t.start()

        #print(thread_list[0])

        #当线程池满时，等待线程结束
    while len(thread_list)>thread_num:  
            #移除已结束线程
        thread_list = [x for x in thread_list if x.is_alive()]
        time.sleep(3)
           # print("running threads_________" + str(thread_list))
   
extract_mp3(downloadfile)
print('***进入切分程序***')
time_4=datetime.now()


   

#第三部分代码
#功能：开始切分语音，并保存到chunks文件夹下
from pydub import AudioSegment
from pydub.silence import split_on_silence
import os
import threading
import you_get
import threading
import os
import time
import pandas as pd
import subprocess

time_5=datetime.now()

def split_audio(audiopath,chunks_path):
    #定义分解函数，方便后面多线程调用
    sound = AudioSegment.from_file(audiopath, format='mp3')
    chunks = split_on_silence(sound,min_silence_len=520,silence_thresh=-30,keep_silence=800)#min_silence_len: 拆分语句时，静默满0.3秒则拆分。silence_thresh：小于-70dBFS以下的为静默。
    filepath = os.path.split(audiopath)[0]
    chunks_path = filepath+'\\chunks\\'
    if not os.path.exists(chunks_path):os.mkdir(chunks_path)
    for i in range(len(chunks)):
        new = chunks[i]
        save_name = chunks_path+audioname+'%04d.%s'%(i,audiotype)
        new.export(save_name, format=audiotype)

# 初始化
audiofile = "C:\\Users\\Administrator\\Desktop\\test2\\"
onum=0
upnum=100
for i in os.listdir(audiofile):
    #将mp3进行重命名，命名成数字，避免中文出现问题
    if  os.path.splitext(i)[-1]=='.mp3':
        
        onum+=1
        onewname=audiofile+str(upnum)+'.mp3'
        
        os.rename(audiofile+i,onewname)
        upnum+=1

thread_list = []
    
thread_num = 6

for i in range(100,100+onum,1):
    audioname=str(i)
    audiopath=audiofile+audioname+'.mp3'
    t = threading.Thread(target=split_audio, args=(audiopath,chunks_path))
    thread_list.append(t)
    t.start()

    while len(thread_list)>thread_num:  
            #移除已结束线程
        thread_list = [x for x in thread_list if x.is_alive()]
        time.sleep(3)

    # print(audiopath)
    #audiotype = 'mp3' #如果wav、mp4其他格式参看pydub.AudioSegment的API
# 读入音频
    # print('读入音频')
    #sound = AudioSegment.from_file(audiopath, format=audiotype)
# sound = sound[:3*60*1000] #如果文件较大，先取前3分钟测试，根据测试结果，调整参数
# 分割 
    # print('开始分割')
    #chunks = split_on_silence(sound,min_silence_len=520,silence_thresh=-30,keep_silence=800)#min_silence_len: 拆分语句时，静默满0.3秒则拆分。silence_thresh：小于-70dBFS以下的为静默。
# 创建保存目录
    #filepath = os.path.split(audiopath)[0]
    #chunks_path = filepath+'\\chunks\\'
   # print(chunks_path)
    #if not os.path.exists(chunks_path):os.mkdir(chunks_path)
# 保存所有分段
    # print('开始保存')
    #for i in range(len(chunks)):
       # new = chunks[i]
       # save_name = chunks_path+audioname+'%04d.%s'%(i,audiotype)
        #new.export(save_name, format=audiotype)
        # print('%04d'%i,len(new))

# print('保存完毕')
print('***运行格式转换代码***')
time_6=datetime.now()




#第四部分代码
#功能：将已经切分好的语音转换为阿里云平台可识别的指定格式
import os
time_7=datetime.now()
to_trans_file="C:\\Users\\Administrator\\Desktop\\test2\\chunks\\"
to_save_trans="C:\\Users\\Administrator\\Desktop\\test2\\转wav\\"
import subprocess
for i in os.listdir(to_trans_file):
    trans_name=to_trans_file+i
    save_name=to_save_trans+os.path.splitext(i)[0]+'.pcm'
    code='ffmpeg -y -i ' +trans_name+' -acodec pcm_s16le -f s16le -ac 1 -ar 16000 '+save_name
    subprocess.check_output(code,shell=True)
# print('pcm格式转换完成')
print('***运行阿里云代码***')
time_8=datetime.now()




#第五部分代码
#功能：上传阿里云平台识别并返回识别结果
# -*- coding: UTF-8 -*-
# Python 2.x引入httplib模块
# import httplib
# Python 3.x引入http.client模块
import pandas as pd
import http.client
from datetime import datetime
import json
from pydub import AudioSegment
from pydub.silence import split_on_silence
import os
import threading
import you_get
import threading
import os
import time
import pandas as pd
import subprocess

time_9=datetime.now()

def process(request, token, audioFile) :

    # 读取音频文件
    with open(audioFile, mode = 'rb') as f:
        audioContent = f.read()

    host = 'nls-gateway-cn-shanghai.aliyuncs.com'

    # 设置HTTPS请求头部
    httpHeaders = {
        'X-NLS-Token': token,
        'Content-type': 'application/octet-stream',
        'Content-Length': len(audioContent)
        }


    # Python 2.x使用httplib
    # conn = httplib.HTTPConnection(host)

    # Python 3.x使用http.client
    conn = http.client.HTTPConnection(host)
    conn.request(method='POST', url=request, body=audioContent, headers=httpHeaders)
    response = conn.getresponse()
    # print('Response status and response reason:')
    # print(response.status ,response.reason)
    body = response.read()
    try:
        # print('Recognize response is:')
        body = json.loads(body)
        # print(body)

        status = body['status']
        if status == 20000000 :
            result = body['result']
#           # print('Recognize result: ' + result)
            return result
        else :
            print('Recognizer failed!')

    except ValueError:
        print('The response is not json format string')

    conn.close()

#!/usr/bin/env python
# -*- coding: utf-8 -*-
import base64
import hashlib
import hmac
import requests
import time
import uuid
from urllib import parse
import pandas as pd
import http.client
from datetime import datetime
import json
from pydub import AudioSegment
from pydub.silence import split_on_silence
import os
import threading
import you_get
import threading
import os
import time
import pandas as pd
import subprocess

class AccessToken:
    @staticmethod
    def _encode_text(text):
        encoded_text = parse.quote_plus(text)
        return encoded_text.replace('+', '%20').replace('*', '%2A').replace('%7E', '~')
    @staticmethod
    def _encode_dict(dic):
        keys = dic.keys()
        dic_sorted = [(key, dic[key]) for key in sorted(keys)]
        encoded_text = parse.urlencode(dic_sorted)
        return encoded_text.replace('+', '%20').replace('*', '%2A').replace('%7E', '~')
    @staticmethod
    def create_token(access_key_id, access_key_secret):
        parameters = {'AccessKeyId': access_key_id,
                      'Action': 'CreateToken',
                      'Format': 'JSON',
                      'RegionId': 'cn-shanghai',
                      'SignatureMethod': 'HMAC-SHA1',
                      'SignatureNonce': str(uuid.uuid1()),
                      'SignatureVersion': '1.0',
                      'Timestamp': time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                      'Version': '2019-02-28'}
        # 构造规范化的请求字符串
        query_string = AccessToken._encode_dict(parameters)
        #print('规范化的请求字符串: %s' % query_string)
        # 构造待签名字符串
        string_to_sign = 'GET' + '&' + AccessToken._encode_text('/') + '&' + AccessToken._encode_text(query_string)
        #print('待签名的字符串: %s' % string_to_sign)
        # 计算签名
        secreted_string = hmac.new(bytes(access_key_secret + '&', encoding='utf-8'),
                                   bytes(string_to_sign, encoding='utf-8'),
                                   hashlib.sha1).digest()
        signature = base64.b64encode(secreted_string)
        #print('签名: %s' % signature)
        # 进行URL编码
        signature = AccessToken._encode_text(signature)
        #print('URL编码后的签名: %s' % signature)
        # 调用服务
        full_url = 'http://nls-meta.cn-shanghai.aliyuncs.com/?Signature=%s&%s' % (signature, query_string)
        # print('url: %s' % full_url)
        # 提交HTTP GET请求
        response = requests.get(full_url)
        if response.ok:
            root_obj = response.json()
            key = 'Token'
            if key in root_obj:
                token = root_obj[key]['Id']
                expire_time = root_obj[key]['ExpireTime']
                return token, expire_time
        #print(response.text)
        return None, None
if __name__ == "__main__":
    # 用户信息
    access_key_id = 'LTAI5tDCdQARDVh2XYMjJGLa'
    access_key_secret = 'znwuFhoqj6i9ojEwZWuPE4Hmp8anzs'
    token, expire_time = AccessToken.create_token(access_key_id, access_key_secret)
   # print('token: %s, expire time(s): %s' % (token, expire_time))
    if expire_time:
        # print('token有效期的北京时间：%s' % (time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(expire_time))))


appKey = 'gF3HRZAKLeo6uD84'

# 服务请求地址
url = 'https://nls-gateway-cn-shanghai.aliyuncs.com/stream/v1/asr'

# 音频文件
# audioFile = '/path/to/nls-sample-16k.wav'
format = 'pcm'
sampleRate = 16000
enablePunctuationPrediction  = True
enableInverseTextNormalization = True
enableVoiceDetection  = False

# 设置RESTful请求参数
request = url + '?appkey=' + appKey
request = request + '&format=' + format
request = request + '&sample_rate=' + str(sampleRate)

if enablePunctuationPrediction :
    request = request + '&enable_punctuation_prediction=' + 'true'

if enableInverseTextNormalization :
    request = request + '&enable_inverse_text_normalization=' + 'true'

if enableVoiceDetection :
    request = request + '&enable_voice_detection=' + 'true'

# print('Request: ' + request)


data2=pd.DataFrame(data=None,columns=['编号','语音内容'])

trans_wav="C:\\Users\\Administrator\\Desktop\\test2\\转wav"
    # 测试时候在此处正确填写相关信息即可运行
time1 = datetime.now()
for i in os.listdir(trans_wav):
    num=os.path.splitext(i)[0]
    xunfei_wav=trans_wav+'\\'+i
    audioFile = xunfei_wav
    result= process(request, token, audioFile)
    # print(num,result)
    dic ={'编号':num,'语音内容':result}
    data1=pd.DataFrame(dic,index=[0])
    data2=data2.append(data1,ignore_index=True)
    
time2 = datetime.now()
# print(time2-time1)
now_time=datetime.now().strftime('%Y%m%d%H%M%S')
trans_txt=now_time+'.txt'
log_file="C:\\Users\\Administrator\\Desktop\\test2\\日志\\"+trans_txt
data2.to_csv(log_file,index=False,sep=' ')
print('***运行重命名代码***')
time_10=datetime.now()




#第六部分代码
#功能：重命名代码，将阿里云返回识别结果重新命名文件        
import pandas as pd
import numpy as py
import os
time_11=datetime.now()
rename_file="C:\\Users\\Administrator\\Desktop\\test2\\chunks\\"
data3=data2.groupby(data2['编号'])['语音内容'].apply(lambda x:x.str.cat(sep=''))
import numpy as py
no_logo=['*',':','\'','<','>','|','\\','/','?']

for i in no_logo:
    data3 =data3.apply(lambda x:x.replace( i,''))
    data3=data3.apply(lambda x:x[:80] if len(x)>81 else x)
data3=data3.dropna(axis=0,how='any')
data3.drop(data3[data3.values==''].index,inplace=True)
data3.drop_duplicates(keep='first',inplace=True)
for i in os.listdir(rename_file):
    for j in data3.index:
        jstr=str(j)
        jj=jstr.zfill(6)

        if os.path.splitext(i)[0]==jj:
            old_file=rename_file+i
#好兄弟加后缀的话放在这里，下面带#的代码就是例子，比这来
#new_file=rename_file+data3[j]+'（素材分享群：123593137，获取更多素材）.mp3'
            new_file=rename_file+data3[j]+'.mp3'
            os.rename(old_file,new_file)
# print('重命名完成')
data2['编号']=data2['编号'].astype(str)

for i in os.listdir(rename_file):
    for j in data2['编号']:
        jstr=str(j)
        jj=jstr.zfill(6)


        if os.path.exists(rename_file+jj+'.mp3'):

            os.remove(rename_file+jj+'.mp3')

# print('空白语音跟重复语音已删除')
print('***运行压缩文件代码***')
time_12=datetime.now()




#第七部分代码
#功能：自动压缩成文件
import os
import zipfile

time_13=datetime.now()
 
def zipDir(source_dir, output_filename):
    """
    压缩指定文件夹
    :param source_dir: 目标文件夹路径
    :param output_filename: 压缩文件保存路径+xxxx.zip
    :return: 无
    """
    if os.path.exists(source_dir):
        # compression压缩比例，默认是不压缩，ZIP_LZMA=14级别的压缩，影响的是时间，但是包能更小
        # vue使用级别=9的，var archive = archiver('zip', {zlib: {level: 9}});
        # mac install: brew install xz
        # mode 解压是 r , 压缩是 w 追加压缩是 a
        # compression 为  zipfile.ZIP_DEFLATED，zipfile.ZIP_STORED， zipfile.ZIP_LZMA
        zipf = zipfile.ZipFile(file=output_filename, mode='w', compression=zipfile.ZIP_LZMA)
        # zipf = zipfile.ZipFile(file=output_filename, mode='w', compression=zipfile.ZIP_DEFLATED)
        pre_len = len(os.path.dirname(source_dir))
        for parent, dirnames, filenames in os.walk(source_dir):
            for filename in filenames:
                pathfile = os.path.join(parent, filename)
                arcname = pathfile[pre_len:].strip(os.path.sep)  # 相对路径
                zipf.write(pathfile, arcname)
        zipf.close()
        return output_filename
    return
 
 
zipDir(
    r'C:\\Users\\Administrator\\Desktop\\test2\\chunks',
    r'C:\\Users\\Administrator\\Desktop\\test2\\请命名.zip')
print('***运行时间统计代码***')

time_14=datetime.now()
timetotal2=datetime.now()




#第八部分代码
#功能统计各个部分的运行时间，方便后面优化，降序排序
import pandas as pd
data_time=pd.DataFrame(data=None,columns=['运行时间','占比'])
time_total=timetotal2-timetotal1
print('代码运行总时间',time_total)

parttime=[time_2-time_1,time_4-time_3,time_6-time_5,time_8-time_7,time_10-time_9,time_12-time_11,time_14-time_13]
zhanbi=['%.2f%%' % (x/time_total * 100) for x in parttime]


datatime={'运行时间':parttime'时间占比':zhanbi}
data_time=pd.DataFrame(datatime,columns=['运行时间','时间占比'],index=['第一部分代码','第二部分代码','第三部分代码','第四部分代码','第五部分代码','第六部分代码','第七部分代码'])
data_time=data_time.sort_values(by='运行时间',ascending=False,axis=0)
data_time

